# .github/workflows/sync-and-patch.yml

name: Sync with Upstream and Patch

on:
  # 1. 定时触发
  schedule:
    - cron: '18 17 * * 0,3'
  # 2. 手动触发：允许在 Actions 页面手动运行此工作流
  workflow_dispatch:

# 设置工作流的默认权限，写入内容和操作 Actions
permissions:
  contents: write
  actions: write

jobs:
  sync_and_build:
    runs-on: ubuntu-latest
    steps:
      # 步骤 a: 检出代码
      # 使用 PAT 令牌以获得推送权限
      # fetch-depth: 0 拉取所有历史记录，以便 git merge-base 可以正常工作
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.FFMPEG_UPDATE_TOKEN }}
          fetch-depth: 0

      # 步骤 b: 检查上游仓库是否有更新 (已改进，可处理不相关历史)
      - name: Check for upstream updates
        id: check_update
        run: |
          # 设置 Git 用户信息，用于后续的 commit
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          UPSTREAM_REPO="https://github.com/BtbN/FFmpeg-Builds.git"
          echo "Adding upstream remote: $UPSTREAM_REPO"
          git remote add upstream $UPSTREAM_REPO
          git fetch upstream master
          
          # 获取上游 master 分支的最新 commit 哈希值
          UPSTREAM_HEAD=$(git rev-parse upstream/master)
          echo "Upstream HEAD: $UPSTREAM_HEAD"
          
          # 尝试寻找共同祖先。如果失败 (exit code 1, 通常意味着不相关历史)，则将 MERGE_BASE 设为空。
          if ! MERGE_BASE=$(git merge-base HEAD upstream/master 2>/dev/null); then
            echo "Warning: git merge-base failed (likely due to unrelated histories). Assuming full update is required."
            MERGE_BASE=""
          fi

          echo "Merge Base:    ${MERGE_BASE:-N/A}"
          
          # 逻辑判断：
          # 1. 如果找到了 MERGE_BASE 并且它不等于 UPSTREAM_HEAD，说明有新更新。
          # 2. 如果 MERGE_BASE 为空 (即 merge-base 失败)，则强制视为有更新。
          if [ -z "$MERGE_BASE" ] || [ "$MERGE_BASE" != "$UPSTREAM_HEAD" ]; then
            echo "Update required (either new commits found or histories are unrelated)."
            echo "has_update=true" >> $GITHUB_OUTPUT
          else
            echo "No new commits found in upstream."
            echo "has_update=false" >> $GITHUB_OUTPUT
          fi

      # 步骤 c: 备份工作流文件并强制重置到上游状态
      - name: Backup workflow and reset to upstream
        run: |
          echo "Backing up workflow files to /tmp/"
          # 备份 sync-and-patch.yml
          cp .github/workflows/sync-and-patch.yml /tmp/sync-and-patch.yml
          # 备份 clear-dockers.yml（如果存在）
          if [ -f .github/workflows/clear-dockers.yml ]; then
            cp .github/workflows/clear-dockers.yml /tmp/clear-dockers.yml
            echo "Backed up clear-dockers.yml"
          else
            echo "clear-dockers.yml not found, skipping backup"
          fi
          
          echo "Resetting current branch to upstream/master"
          git reset --hard upstream/master

      # 步骤 d: 安装 yq 并对 build.yml 应用补丁
      - name: Install yq and patch build.yml
        run: |
          echo "Installing yq..."
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq
          
          WORKFLOW_FILE=".github/workflows/build.yml"
          echo "Patching $WORKFLOW_FILE..."
          
          # (1) 修改仓库名检查，使其适配当前仓库
          yq eval -i '.jobs.pre_check.steps[0].run |= sub("BtbN/FFmpeg-Builds", "${{ github.repository }}")' $WORKFLOW_FILE
          
          # (2) 移除 push 和 schedule 触发器，防止自动构建
          yq eval -i 'del(.on.push) | del(.on.schedule)' $WORKFLOW_FILE
          
          # (2.1) 新增：添加新的定时触发器 (北京时间周日 01:37 = UTC 17:37 周六)
          # 注意：yq eval -i 命令中，如果值包含引号，需要使用单引号包裹整个表达式
          yq eval -i '.on.schedule = [{"cron": "37 17 * * 6"}]' $WORKFLOW_FILE
          
          # (3) 移除 ARM 和 32位 runner/target
          # yq eval -i '.jobs.build_base.strategy.matrix.runner = ["ubuntu-latest"]' $WORKFLOW_FILE
          # yq eval -i '.jobs.build_target_bases.strategy.matrix.target = ["win64", "linux64"]' $WORKFLOW_FILE
          # yq eval -i '.jobs.build_targets.strategy.matrix.target = ["win64", "linux64"]' $WORKFLOW_FILE
          # yq eval -i '.jobs.build_ffmpeg.strategy.matrix.target = ["win64", "linux64"]' $WORKFLOW_FILE
          
          # (4) 限制 variant 为 nonfree 版本
          yq eval -i '.jobs.build_targets.strategy.matrix.variant = ["nonfree", "nonfree-shared", "nonfree 8.0", "nonfree-shared 8.0", "nonfree 7.1", "nonfree-shared 7.1"]' $WORKFLOW_FILE
          yq eval -i '.jobs.build_ffmpeg.strategy.matrix.variant = ["nonfree", "nonfree-shared", "nonfree 8.0", "nonfree-shared 8.0", "nonfree 7.1", "nonfree-shared 7.1"]' $WORKFLOW_FILE

          # (5) 修改发布创建的目标分支为默认分支
          
          # 使用 yq 精确修改 Create release 步骤中的目标分支
          yq eval -i '(.jobs.publish_release.steps[] | select(.name == "Create release").run) |= sub("--target \"master\"", "--target \"${{ github.event.repository.default_branch }}\"")' $WORKFLOW_FILE
          # 使用 yq 精确修改 Update Latest 步骤中的目标分支
          yq eval -i '(.jobs.publish_release.steps[] | select(.name == "Update Latest").run) |= sub("--target \"master\"", "--target \"${{ github.event.repository.default_branch }}\"")' $WORKFLOW_FILE

          echo "Patching complete."

      # 步骤 e: 恢复工作流文件
      - name: Restore workflow files
        run: |
          echo "Restoring workflow files from /tmp/"
          # 确保目录存在
          mkdir -p .github/workflows
          # 恢复 sync-and-patch.yml
          cp /tmp/sync-and-patch.yml .github/workflows/sync-and-patch.yml
          # 恢复 clear-dockers.yml（如果备份存在）
          if [ -f /tmp/clear-dockers.yml ]; then
            cp /tmp/clear-dockers.yml .github/workflows/clear-dockers.yml
            echo "Restored clear-dockers.yml"
          else
            echo "clear-dockers.yml backup not found, skipping restore"
          fi

      # 步骤 e+0.5: 提交并强制推送到仓库
      - name: Commit and push changes
        run: |
          git add .
          # 检查是否有文件变动，只有在有变动时才提交和推送
          if ! git diff --staged --quiet; then
            echo "Changes detected, committing and pushing..."
            git commit -m "chore: Sync with upstream and apply patches"
            # 使用 --force 是必需的，因为我们用了 git reset --hard 来重写历史
            git push origin ${{ github.ref_name }} --force
          else
            echo "No changes to commit."
          fi

      # 步骤 f: 如果有更新，则触发 build.yml
      - name: Trigger build workflow if updated
        # 仅当步骤 'check_update' 的输出 has_update 为 'true' 时运行
        if: steps.check_update.outputs.has_update == 'true'
        env:
          # 使用 PAT 进行认证，以触发另一个工作流
          GH_TOKEN: ${{ secrets.FFMPEG_UPDATE_TOKEN }}
          # 获取当前分支名
          CURRENT_BRANCH: ${{ github.ref_name }}
        run: |
          echo "Triggering 'build.yml' workflow on branch '$CURRENT_BRANCH'..."
          # 等待几秒钟，确保 Git 推送已在 GitHub 端完全处理
          sleep 15
          gh workflow run build.yml --ref $CURRENT_BRANCH --repo ${{ github.repository }} -f doRelease=true
